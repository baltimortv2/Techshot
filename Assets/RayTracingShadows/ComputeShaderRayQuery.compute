#include "UnityRayQuery.cginc"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/GBufferCommon.hlsl"

// Ray Traced Shadows - Extended version with Spot Light support
// Based on: https://github.com/INedelcu/InlineRayTracingShadows

#pragma kernel CSMain

#pragma require inlineraytracing

#pragma multi_compile _ _GBUFFER_NORMALS_OCT



half3 UnpackNormalRGBNoScale(half4 packedNormal)
{
    return packedNormal.rgb * 2.0 - 1.0;
}

half3 UnpackNormal(half4 packedNormal)
{
    return UnpackNormalRGBNoScale(packedNormal);
}

// Input
RaytracingAccelerationStructure     g_AccelStruct;

uint                                g_FrameIndex;
uint                                g_TemporalAccumulationStep;
float                               g_ShadowSpread;
float                               g_ShadowIntensity;
float3                              g_LightDir;
float4x4                            g_LightMatrix;
float4                              g_DepthToViewParams;

// Light type: 0 = Directional, 1 = Spot
uint                                g_LightType;
float3                              g_LightPosition;
float                               g_LightRange;
float                               g_SpotAngleCos;      // cos(spotAngle/2)
float                               g_SpotInnerAngleCos; // cos(innerSpotAngle/2) for smooth falloff

// Debug
uint                                g_DebugForceConstantOutput;
float                               g_DebugConstantOutput;

// Techshot RTS quality controls
uint                                g_UseFixedSampleCount;
uint                                g_FixedSampleCount;
uint                                g_UseOccluderDistance;
float                               g_OccluderDistanceScale;
float                               g_ShadowMaxDistance;
float                               g_ShadowReceiverMaxDistance;
float                               g_ShadowDistanceFade;
uint                                g_EnableDenoise;
float                               g_DenoiseStrength;
float                               g_DenoiseMinBlend;

Texture2D<float>                    _DepthBuffer;
Texture2D<float4>                   _GBuffer2;

float4x4 g_CameraToWorld;

// Output
RWTexture2D<float>                  g_Output;

// Random function
uint WangHash(inout uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float RandomFloat01(inout uint seed)
{
    return float(WangHash(seed)) / float(0xFFFFFFFF);
}

float TechshotLinearEyeDepth(float depth, float4 zBufferParam)
{
    return 1.0 / (zBufferParam.z * depth + zBufferParam.w);
}

// Spot light attenuation
float GetSpotAttenuation(float3 worldPos)
{
    float3 toLight = g_LightPosition - worldPos;
    float distance = length(toLight);
    
    if (distance > g_LightRange)
        return 0;
    
    float3 lightDir = toLight / distance;
    float cosAngle = dot(lightDir, -g_LightDir);
    
    if (cosAngle < g_SpotAngleCos)
        return 0;

    float denom = max(1e-5, (g_SpotInnerAngleCos - g_SpotAngleCos));
    float spotAtten = saturate((cosAngle - g_SpotAngleCos) / denom);
    float distAtten = saturate(1.0 - (distance / g_LightRange));

    return spotAtten * distAtten;
}

[numthreads(8, 4, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _DepthBuffer.GetDimensions(width, height);

    if (id.x >= width || id.y >= height)
        return;

    if (g_DebugForceConstantOutput != 0)
    {
        g_Output[id.xy] = saturate(g_DebugConstantOutput);
        return;
    }

    float rawDepth = _DepthBuffer[id.xy];
    if (rawDepth == 0)
    {
        g_Output[id.xy] = 1;
        return;
    }    

    half3 packedNormal = (half3)_GBuffer2[id.xy].xyz;
    float3 worldNormal = normalize(UnpackGBufferNormal(packedNormal));

    float deviceDepth = rawDepth;
    #if !UNITY_REVERSED_Z
        deviceDepth = deviceDepth * 2.0 - 1.0;
    #endif

    float2 uv = (float2(id.xy) + float2(0.5, 0.5)) / float2(width, height);
    uv = UnityStereoTransformScreenSpaceTex(uv);
    uv = uv * _ScreenCoordScaleBias.xy + _ScreenCoordScaleBias.zw;
    float3 worldSpacePos = ComputeWorldSpacePosition(uv, deviceDepth, unity_MatrixInvVP);

    if (g_ShadowReceiverMaxDistance > 0.0)
    {
        float receiverDist = distance(worldSpacePos, _WorldSpaceCameraPos);
        if (receiverDist > g_ShadowReceiverMaxDistance)
        {
            g_Output[id.xy] = 1;
            return;
        }
    }

    float3 rayDirection;
    float maxRayDistance;
    float lightAttenuation = 1.0;
    
    if (g_LightType == 0) // Directional
    {
        if (dot(g_LightDir, worldNormal) >= -0.05f)
        {
            g_Output[id.xy] = 1;
            return;
        }
        rayDirection = -g_LightDir;
        maxRayDistance = (g_ShadowMaxDistance > 0.0) ? g_ShadowMaxDistance : 1e20f;
    }
    else // Spot
    {
        float3 toLight = g_LightPosition - worldSpacePos;
        float distToLight = length(toLight);
        
        if (distToLight > g_LightRange)
        {
            g_Output[id.xy] = 1;
            return;
        }
        
        rayDirection = toLight / distToLight;
        
        if (dot(rayDirection, worldNormal) <= 0.0f)
        {
            g_Output[id.xy] = 1;
            return;
        }
        
        lightAttenuation = GetSpotAttenuation(worldSpacePos);
        if (lightAttenuation <= 0)
        {
            g_Output[id.xy] = 1;
            return;
        }
        
        maxRayDistance = distToLight - 0.01f;
    }

    uint rngState = uint(uint(id.x) * uint(1973) + uint(id.y) * uint(9277) + uint(g_FrameIndex) * uint(26699)) | uint(1);

    RayDesc shadowRay;
    shadowRay.Origin = worldSpacePos + worldNormal * 0.01f;
    shadowRay.TMin = 0;
    shadowRay.TMax = maxRayDistance;

    UnityRayQuery<RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH> shadowQuery;

    uint baseSampleCount = (g_TemporalAccumulationStep < 10) ? 8u : 2u;
    uint sampleCount = (g_UseFixedSampleCount != 0) ? max(1u, g_FixedSampleCount) : baseSampleCount;

    float shadow = 0;

    for (uint i = 0; i < sampleCount; i++)
    {
        float3 jitteredDir;
        
        if (g_LightType == 0)
        {
            float3 localDir = normalize(float3(g_ShadowSpread, g_ShadowSpread, 1) * float3(2 * RandomFloat01(rngState) - 1, 2 * RandomFloat01(rngState) - 1, 1));
            jitteredDir = mul(g_LightMatrix, localDir);
        }
        else
        {
            float jitterX = (2 * RandomFloat01(rngState) - 1) * g_ShadowSpread * 0.1;
            float jitterY = (2 * RandomFloat01(rngState) - 1) * g_ShadowSpread * 0.1;
            float3 tangent = abs(rayDirection.y) < 0.99 ? cross(rayDirection, float3(0, 1, 0)) : cross(rayDirection, float3(1, 0, 0));
            tangent = normalize(tangent);
            float3 bitangent = cross(rayDirection, tangent);
            jitteredDir = normalize(rayDirection + tangent * jitterX + bitangent * jitterY);
        }
        
        shadowRay.Direction = jitteredDir;
        shadowQuery.TraceRayInline(g_AccelStruct, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xff, shadowRay);
        shadowQuery.Proceed();

        if (shadowQuery.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
        {
            float weight = 1.0;
            if (g_UseOccluderDistance != 0)
            {
                float t = shadowQuery.CommittedRayT();
                weight *= saturate(1.0 - t * g_OccluderDistanceScale);
            }
            if (g_ShadowDistanceFade > 0.0)
            {
                float t = shadowQuery.CommittedRayT();
                weight *= exp(-t * g_ShadowDistanceFade);
            }
            shadow += weight;
        }
    }
    
    float prevShadow = g_Output[id.xy];
    shadow *= g_ShadowIntensity * lightAttenuation;
    float s = shadow / (float)sampleCount;
    float newShadow = 1.0 - s;

    float lerpAlpha = 1.0 / float(g_TemporalAccumulationStep + 1);
    if (g_EnableDenoise != 0)
    {
        float k = saturate(g_DenoiseStrength);
        lerpAlpha = lerp(lerpAlpha, lerpAlpha * 0.25, k);
        lerpAlpha = max(lerpAlpha, g_DenoiseMinBlend);
    }

    g_Output[id.xy] = lerp(prevShadow, newShadow, lerpAlpha);
}
